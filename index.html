<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="dist/output.css" />
    <link rel="stylesheet" href="style.css" />
    <link rel="stylesheet" href="gothic-font.css" />
    <title>Document</title>
  </head>
  <body class="dotgothic16-regular selection-yellow">
    <main class="h-screen w-full px-4 bg-[#101010]">
      <section class="w-full flex justify-center pt-10">
        <h1 class="flex text-[64px] font-normal">
          <span class="text-[#009365]">{{ titleDoc }}</span>
          <span class="text-[#FFB936]">{{ titleWave }}</span>
        </h1>
      </section>

      <section class="pt-14 flex justify-center">
        <div class="w-[950px]">
          <h2 class="text-[#FFB936] text-sm font-normal uppercase">
            {{ inputTitle }}
          </h2>
          <div class="flex items-center gap-1 pt-2">
            <input
              class="w-full p-2.5 text-[#FFB936] placeholder:uppercase border-2 border-[#009365] bg-[#FFB936]/40 outline-0"
              type="text"
              placeholder="{{ inputPlaceholder }}"
            />
            <button
              class="p-2.5 border-2 border-[#009365] bg-[#FFB936]/40 cursor-pointer hover:bg-[#FFB936]"
            >
              <svg
                width="24"
                height="24"
                viewBox="0 0 24 24"
                xmlns="http://www.w3.org/2000/svg"
              >
                <path d="M12 15H14V9H16.5L12 4.5M12 15H10V9H7.5L12 4.5" />
                <path
                  d="M12 15H14V9H16.5L12 4.5L7.5 9H10V15H12Z"
                  stroke="#000000"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                />
                <path
                  d="M6 19H18"
                  stroke="#000000"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                />
              </svg>
            </button>
          </div>
        </div>
      </section>

      <section class="pt-6 flex justify-center">
        <div class="max-w-[950px] border-2 border-[#009365] px-7 py-5">
          <h2 class="mb-2 text-[#FFB936] text-sm font-normal uppercase">
            {{ outputTitle }}
          </h2>
          <!-- TODO: display markdown -->
          <div
            class="custom-scroll w-full h-[650px] overflow-y-scroll p-4 text-white text-sm font-normal border-2 border-[#009365]"
          >
            Imagine you're developing a killer web app that has three main
            components - a React frontend, a Python API, and a PostgreSQL
            database. If you wanted to work on this project, you'd have to
            install Node, Python, and PostgreSQL. How do you make sure you have
            the same versions as the other developers on your team? Or your
            CI/CD system? Or what's used in production? How do you ensure the
            version of Python (or Node or the database) your app needs isn't
            affected by what's already on your machine? How do you manage
            potential conflicts? Enter containers! What is a container? Simply
            put, containers are isolated processes for each of your app's
            components. Each component - the frontend React app, the Python API
            engine, and the database - runs in its own isolated environment,
            completely isolated from everything else on your machine. Here's
            what makes them awesome. Containers are: Self-contained. Each
            container has everything it needs to function with no reliance on
            any pre-installed dependencies on the host machine. Isolated. Since
            containers are run in isolation, they have minimal influence on the
            host and other containers, increasing the security of your
            applications. Independent. Each container is independently managed.
            Deleting one container won't affect any others. Portable. Containers
            can run anywhere! The container that runs on your development
            machine will work the same way in a data center or anywhere in the
            cloud! Containers versus virtual machines (VMs) Without getting too
            deep, a VM is an entire operating system with its own kernel,
            hardware drivers, programs, and applications. Spinning up a VM only
            to isolate a single application is a lot of overhead. A container is
            simply an isolated process with all of the files it needs to run. If
            you run multiple containers, they all share the same kernel,
            allowing you to run more applications on less infrastructure.
            Explanation Seeing a container is an isolated process, where does it
            get its files and configuration? How do you share those
            environments? That's where container images come in. A container
            image is a standardized package that includes all of the files,
            binaries, libraries, and configurations to run a container. For a
            PostgreSQL image, that image will package the database binaries,
            config files, and other dependencies. For a Python web app, it'll
            include the Python runtime, your app code, and all of its
            dependencies. There are two important principles of images: Images
            are immutable. Once an image is created, it can't be modified. You
            can only make a new image or add changes on top of it. Container
            images are composed of layers. Each layer represents a set of file
            system changes that add, remove, or modify files. These two
            principles let you to extend or add to existing images. For example,
            if you are building a Python app, you can start from the Python
            image and add additional layers to install your app's dependencies
            and add your code. This lets you focus on your app, rather than
            Python itself. Finding images Docker Hub is the default global
            marketplace for storing and distributing images. It has over 100,000
            images created by developers that you can run locally. You can
            search for Docker Hub images and run them directly from Docker
            Desktop. Docker Hub provides a variety of Docker-supported and
            endorsed images known as Docker Trusted Content. These provide fully
            managed services or great starters for your own images. These
            include: Docker Official Images - a curated set of Docker
            repositories, serve as the starting point for the majority of users,
            and are some of the most secure on Docker Hub Docker Verified
            Publishers - high-quality images from commercial publishers verified
            by Docker Docker-Sponsored Open Source - images published and
            maintained by open-source projects sponsored by Docker through
            Docker's open source program For example, Redis and Memcached are a
            few popular ready-to-go Docker Official Images. You can download
            these images and have these services up and running in a matter of
            seconds. There are also base images, like the Node.js Docker image,
            that you can use as a starting point and add your own files and
            configurations.
          </div>
        </div>
      </section>
    </main>
  </body>
</html>
